# RecyclerView的四级缓存结构 - 第三级缓存

## 第三级缓存：mViewCacheExtension

### 特点

- 完全由开发者自定义的缓存策略
- 默认为null，需要开发者实现并设置
- 位于mCachedViews和mRecyclerPool之间

### 使用场景

适用于需要特定缓存逻辑的场景，例如：

- 固定位置的Item使用专门的缓存策略
- 特殊类型的Item使用自定义的缓存逻辑
- 需要更大缓存容量但又不想增加mCachedViews大小

### 源码分析

**定义接口**：

```java
public abstract static class ViewCacheExtension {
    public abstract View getViewForPositionAndType(Recycler recycler, int position, int type);
}
```

**使用方式**：

```java
// 在RecyclerView中设置
recyclerView.setViewCacheExtension(new MyViewCacheExtension());

// 自定义实现
class MyViewCacheExtension extends RecyclerView.ViewCacheExtension {
    private SparseArray<View> mViews = new SparseArray<>();

    @Override
    public View getViewForPositionAndType(RecyclerView.Recycler recycler, int position, int type) {
        return mViews.get(position);
    }

    public void cacheView(int position, View view) {
        mViews.put(position, view);
    }
}
```

**在Recycler中获取**：

```java
ViewHolder tryGetViewHolderForPositionByDeadline(int position, boolean dryRun, long deadlineNs) {
    // 尝试从mAttachedScrap和mCachedViews获取...

    // 尝试从mViewCacheExtension获取
    if (mAdapter.hasStableIds()) {
        // ...
    }

    if (mViewCacheExtension != null) {
        final View view = mViewCacheExtension.getViewForPositionAndType(this, position, type);
        if (view != null) {
            ViewHolder holder = getChildViewHolder(view);
            if (holder != null) {
                // ... 检查ViewHolder状态 ...
                return holder;
            }
        }
    }

    // 如果没有找到，尝试从mRecyclerPool获取...
}
``` 